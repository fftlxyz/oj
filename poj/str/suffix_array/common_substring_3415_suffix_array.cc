
#include <stdio.h>

// 这个题目在<<后缀数组-字符串处理的有力工具中>>有提到
//
// 基本思路是计算 A 的所有后缀和 B 的所有后缀之间的最长公共前缀的长度,
//
// 把最长公共前缀长度不小于 k 的部分全部加起来。先将两个字符串连起来,中间
// 用一个没有出现过的字符隔开。
//
// 按height值分组后,接下来的工作便是快速的统计每组中后缀之间的最长公共前缀之和。// 作用??
//
// 扫描一遍,每遇到一个 B 的后缀就统计与前面的 A 的后缀能产生多少个长度不小于 k 的公共子串,
// 这里 A 的后缀需要用一个单调的栈来高效的维护。
//
// 然后对 A 也这样做一次。
// 具体的细节留给读者思考。
//
// A:xx
// B:xx
// xx$xx
//
// 后缀数组:
// $xx
// x
// x$xx
// xx
// xx$xx
//
// 如果统计每个A的后缀和在它前面B的后缀的最长公共前缀
// 然后,再统计每个B的后缀和在它前面A的后缀的最长公共前缀
// 就可以知道结果.
//
// 如果比较朴素的方法来做的话,那就统计LCP时间就是O(n^2)
// 这个题目中n是10^5, 时间是5s, 要TLE的, 那怎么快速统计呢
//
// 在 <<后缀数组-字符串处理的有力工具中有提到>> 提到什么单调栈，什么玩意，怎么玩?
//
// Sun Mar 24 09:35:32 CST 2013

int main(int argc, const char *argv[])
{
    return 0;
}
